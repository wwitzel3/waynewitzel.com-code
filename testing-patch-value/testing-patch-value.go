package main

import (
	"fmt"
)

// This represents 3rd party code that we do not want to modify/maintain.
// --- 3RD PARTY
type ProjectService struct{}
type Project struct {
	tag string
}

func (ProjectService) Do() (*Project, error) {
	return &Project{tag: "p1"}, nil
}

func (p Project) Tag() string {
	return p.tag
}

type EmailService struct{}
type Email struct {
	tag string
}

func (EmailService) Do() (*Email, error) {
	return &Email{tag: "e1"}, nil
}

func (e Email) Tag() string {
	return e.tag
}

// --- 3RD PARTY

type Services struct {
	project *ProjectService
	email   *EmailService
}

var doCall = func(svc Services) (interface{}, error) {
	if svc.project != nil {
		return svc.project.Do()
	} else if svc.email != nil {
		return svc.email.Do()
	}
	return nil, fmt.Errorf("no matching service found")
}

func getProject() (*Project, error) {
	svc := Services{
		project: &ProjectService{},
	}

	// Perform the call, return any error generated by the real API
	result, err := doCall(svc)
	if err != nil {
		return nil, err
	}

	// Cast the result back to our expected return type
	project, ok := result.(*Project)
	if !ok {
		return nil, fmt.Errorf("unable to type-cast result to Project")
	}

	return project, nil
}

func getEmail() (*Email, error) {
	svc := Services{
		email: &EmailService{},
	}

	result, err := doCall(svc)
	if err != nil {
		return nil, err
	}

	email, ok := result.(*Email)
	if !ok {
		return nil, fmt.Errorf("unable to type-cast result to Email")
	}

	return email, nil
}

func main() {
	project, err := getProject()
	if err != nil {
		panic(err)
	}
	// Should print Project!
	fmt.Println(project.Tag())

	email, err := getEmail()
	if err != nil {
		panic(err)
	}
	// Should print Project!
	fmt.Println(email.Tag())
}
